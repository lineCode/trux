// This file is to optimize a state machine generated by compiler.
import * as types from "./types.ts";
import { StateKind, refactorIds } from "./common.ts";

export function optimize(states: types.State[]): types.OptimizerData {
  const paths = getAllPaths(states);
  const fixed: string[] = [];
  const endsWith: string[] = [];
  const dynamicPaths: Array<types.State[]> = [];
  let minLength = Infinity;
  let maxLength = -Infinity;
  let endsWithDisabled = false;

  for (const path of paths) {
    if (isFixed(path)) {
      const data: string[] = [];
      for (const state of path) {
        data.push(state.data);
      }
      const str = data.join("");
      if (!fixed.includes(str)) {
        fixed.push(str);
        if (str.length < minLength) {
          minLength = str.length;
        }
        if (str.length > maxLength) {
          maxLength = str.length;
        }
      }
    } else {
      let len = 0;
      for (const state of path) {
        if (state.kind === StateKind.FIXED) {
          len += state.data.length;
        } else if (state.kind === StateKind.PARAMETERIC) {
          // A PARAMETERIC state must match at least 1 byte.
          len += 1;
        }
      }
      if (len < minLength) {
        minLength = len;
      }
      maxLength = Infinity;
      dynamicPaths.push(path);
      if (!endsWithDisabled) {
        const fixedEnd = getFixedEnd(path);
        if (fixedEnd === "") {
          endsWithDisabled = true;
          endsWith.splice(0);
          endsWith.push("");
        } else if (!endsWith.includes(fixedEnd)) {
          endsWith.push(fixedEnd);
        }
      }
    }
  }

  if (fixed.length === paths.length) {
    return {
      onlyFixed: true,
      minLength,
      maxLength,
      fixed,
      endsWith
    };
  }

  for (let i = 0; i < dynamicPaths.length; ++i) {
    dynamicPaths[i] = joinFixedStates(dynamicPaths[i]);
    dynamicPaths[i] = removeEmptyNodes(dynamicPaths[i]);
    checkPath(dynamicPaths[i]);
  }

  // Remmber: Test for H(:id)H
  // Also H(:id)/(H|P)?

  return {
    onlyFixed: false,
    minLength,
    maxLength,
    fixed,
    endsWith,
    states: remap(dynamicPaths, states)
  };
}

export function joinFixedStates(states: types.Path): types.Path {
  const ret: types.Path = [];

  for (let i = 0; i < states.length; ++i) {
    const state = states[i];
    if (state.kind === StateKind.FIXED) {
      const data: string[] = [state.data];
      let nextState = states[i + 1];
      while (nextState && nextState.kind === StateKind.FIXED) {
        data.push(nextState.data);
        nextState = states[++i + 1];
      }
      ret.push({
        ...state,
        data: data.join("")
      });
    } else {
      ret.push(state);
    }
  }

  return ret;
}

export function removeEmptyNodes(states: types.Path): types.Path {
  const ret: types.Path = [];

  for (const state of states) {
    if (state.kind === StateKind.FIXED) {
      if (state.data === "") {
        continue;
      }
    }
    ret.push(state);
  }

  return ret;
}

// This function is to check two things:
// 1. There shouldn't be two param with the same name in a path.
//  Example:
//    Invalid: "X/:id/:id"
//    Valid: "X/:id/:id2"
// 2. A path must not have two parameteric states next to each other.
//  Example:
//    Invalid: "Y/:r:p"
//    Valid: "Y/:r/:p"
export function checkPath(path: types.Path): void {
  const seen: string[] = [];
  let parametericAllowd = true;

  for (const state of path) {
    if (state.kind === StateKind.PARAMETERIC) {
      if (!parametericAllowd) {
        throw new Error("A parameter must not come after another parameter.");
      }
      if (seen.includes(state.name)) {
        throw new Error("A parameter name must be unique.");
      }
      parametericAllowd = false;
      seen.push(state.name);
    } else {
      parametericAllowd = true;
    }
  }
}

// TODO(qti3e) This could be done much faster.
export function remap(
  paths: Array<types.State[]>,
  preStates: types.State[]
): types.State[] {
  // When we process a pattern like "H(:id)H",
  // we will end up by a path like this:
  // [ fixed("H"), parameteric("id"), fixed("H"), end() ]
  // And in this case if we consider these two Hs equal, then
  // we will end up with an infinte loop.
  // So basically, what we're doing here is searching paths for
  // duplicated fixed nodes and push them into the `circular`
  // array.
  const circular: string[] = [];
  for (const path of paths) {
    const seen: string[] = [];
    for (const state of path) {
      if (state.kind === StateKind.FIXED) {
        if (seen.indexOf(state.data) > -1) {
          circular.push(state.data);
        } else {
          seen.push(state.data);
        }
      }
    }
  }

  let lastID = 0;
  const dataToID = new Map<string, number>();
  const paramNameToID = new Map<string, number>();
  const prevID2ID = new Map<number, number>();
  const states: types.StatesObj = {};
  const startState: types.StartState = {
    kind: StateKind.START,
    id: ++lastID,
    nextStates: []
  };
  states[lastID] = startState;

  for (const path of paths) {
    if (path.length === 0) {
      continue;
    }
    for (let i = 0; i < path.length + 1; ++i) {
      if (i > 1) {
        const stateA = path[i - 2];
        const stateB = path[i - 1];
        const idA = prevID2ID.get(stateA.id);
        const idB = prevID2ID.get(stateB.id);
        if (states[idA].nextStates.indexOf(idB) < 0) {
          states[idA].nextStates.push(idB);
        }
      }
      if (i === path.length) {
        break;
      }
      const state = path[i];
      if (prevID2ID.has(state.id)) {
        continue;
      }
      const id = ++lastID;
      switch (state.kind) {
        case StateKind.FIXED:
          if (circular.indexOf(state.data) < 0) {
            if (dataToID.has(state.data)) {
              prevID2ID.set(state.id, dataToID.get(state.data));
              continue;
            }
          }
          prevID2ID.set(state.id, id);
          dataToID.set(state.data, id);
          states[id] = {
            kind: StateKind.FIXED,
            id,
            data: state.data,
            nextStates: []
          };
          break;
        case StateKind.PARAMETERIC:
          if (paramNameToID.has(state.name)) {
            prevID2ID.set(state.id, paramNameToID.get(state.name));
            continue;
          }
          prevID2ID.set(state.id, id);
          paramNameToID.set(state.name, id);
          states[id] = {
            kind: StateKind.PARAMETERIC,
            id,
            name: state.name,
            nextStates: []
          };
          break;
        case StateKind.END:
          prevID2ID.set(state.id, id);
          states[id] = {
            kind: StateKind.END,
            id,
            nextStates: []
          };
          break;
      }
    }
    const firstId = prevID2ID.get(path[0].id);
    if (startState.nextStates.indexOf(firstId) < 0) {
      startState.nextStates.push(firstId);
    }
  }

  const arr = Object.values(states);
  refactorIds(arr);
  return arr;
}

export function getFixedEnd(path: types.State[]): string {
  const data: string[] = [];
  for (let i = path.length - 1; i >= 0; --i) {
    const state = path[i];
    if (state.kind === StateKind.FIXED) {
      data.push(state.data);
    } else {
      break;
    }
  }
  return data.reverse().join("");
}

export function getAllPaths(states: types.State[]): Array<types.State[]> {
  const ret: Array<types.State[]> = [];

  const statesStack: types.State[] = [states[0]];
  const pathStack: number[] = [-1];

  while (statesStack.length) {
    const selectedPath = pathStack.pop();
    const currentState = statesStack.pop();
    if (currentState.kind === StateKind.END) {
      ret.push([...statesStack.slice(1), currentState]);
    }
    const nextStateId = currentState.nextStates[selectedPath + 1];
    const nextState = states[nextStateId];
    if (!nextStateId) {
      continue;
    }
    statesStack.push(currentState);
    pathStack.push(selectedPath + 1);
    statesStack.push(nextState);
    pathStack.push(-1);
  }

  return ret;
}

function isFixed(path: types.State[]): path is types.FixedStateArray {
  for (const state of path) {
    if (state.kind === StateKind.PARAMETERIC) {
      return false;
    }
  }
  return true;
}
