// This file is to optimize a state machine generated by compiler.
import * as types from "./types.ts";
import { StateKind } from "./common.ts";

let lastID = 0;

export function optimize(paths: Array<types.Path>): types.OptimizerData {
  let minLength = Infinity;
  let maxLength = -Infinity;

  lastID = 0;
  for (let i = 0; i < paths.length; ++i) {
    paths[i] = joinFixedStates(paths[i]);
    paths[i] = removeEmptyNodes(paths[i]);
    checkPath(paths[i]);
    let len = 0;
    for (let s = 0; s < paths[i].length; ++s) {
      const state = paths[i][s];
      switch (state.kind) {
        case StateKind.FIXED:
          len += state.data.length;
          break;
        case StateKind.PARAMETERIC:
          if (state.name !== "_") {
            len += 1;
          }
          maxLength = Infinity;
          break;
      }
    }
    if (len < minLength) { minLength = len; }
    if (len > maxLength) { maxLength = len; }
  }

  if (minLength === Infinity) {
    minLength = -Infinity;
  }

  if (maxLength === -Infinity) {
    maxLength = Infinity;
  }

  // Remmber: Test for H(:id)H
  // Also H(:id)/(H|P)?

  return {
    minLength,
    maxLength,
    states: remap(paths)
  };
}

export function joinFixedStates(states: types.Path): types.Path {
  const ret: types.Path = [];

  for (let i = 0; i < states.length; ++i) {
    const state = states[i];
    if (state.kind === StateKind.FIXED) {
      const data: string[] = [state.data];
      let nextState = states[i + 1];
      while (nextState && nextState.kind === StateKind.FIXED) {
        data.push(nextState.data);
        nextState = states[++i + 1];
      }
      ret.push({
        ...state,
        id: ++lastID,
        data: data.join("")
      });
    } else {
      ret.push({
        ...state,
        id: ++lastID
      });
    }
  }

  return ret;
}

export function removeEmptyNodes(states: types.Path): types.Path {
  const ret: types.Path = [];

  for (let i = 0; i < states.length; ++i) {
    const state = states[i];
    if (state.kind === StateKind.FIXED) {
      if (state.data === "") {
        continue;
      }
    }
    ret.push(state);
  }

  return ret;
}

// This function is to check two things:
// 1. There shouldn't be two param with the same name in a path.
//  Example:
//    Invalid: "X/:id/:id"
//    Valid: "X/:id/:id2"
// 2. A path must not have two parameteric states next to each other.
//  Example:
//    Invalid: "Y/:r:p"
//    Valid: "Y/:r/:p"
export function checkPath(path: types.Path): void {
  const seen: string[] = [];
  let parametericAllowd = true;

  for (let i = 0; i < path.length; ++i) {
    const state = path[i];
    if (state.kind === StateKind.PARAMETERIC) {
      if (!parametericAllowd) {
        throw new Error("A parameter must not come after another parameter.");
      }
      if (seen.includes(state.name)) {
        throw new Error("A parameter name must be unique.");
      }
      parametericAllowd = false;
      seen.push(state.name);
    } else {
      parametericAllowd = true;
    }
  }
}

// TODO(qti3e) This could be done much faster.
export function remap(paths: Array<types.Path>): types.StatesObj {
  // When we process a pattern like "H(:id)H",
  // we will end up by a path like this:
  // [ fixed("H"), parameteric("id"), fixed("H"), end() ]
  // And in this case if we consider these two Hs equal, then
  // we will end up with an infinte loop.
  // So basically, what we're doing here is searching paths for
  // duplicated fixed nodes and push them into the `circular`
  // array.
  const circular: string[] = [];
  for (const path of paths) {
    const seen: string[] = [];
    for (const state of path) {
      if (state.kind === StateKind.FIXED) {
        if (seen.indexOf(state.data) > -1) {
          circular.push(state.data);
        } else {
          seen.push(state.data);
        }
      }
    }
  }

  lastID = -1;
  const dataToID = new Map<string, number>();
  const paramNameToID = new Map<string, number>();
  const prevID2ID = new Map<number, number>();
  const states: types.StatesObj = {};
  const startState: types.StartState = {
    kind: StateKind.START,
    id: ++lastID,
    nextStates: []
  };
  states[lastID] = startState;

  for (const path of paths) {
    if (path.length === 0) {
      continue;
    }
    for (let i = 0; i < path.length + 1; ++i) {
      if (i > 1) {
        const stateA = path[i - 2];
        const stateB = path[i - 1];
        const idA = prevID2ID.get(stateA.id);
        const idB = prevID2ID.get(stateB.id);
        if (states[idA].nextStates.indexOf(idB) < 0) {
          states[idA].nextStates.push(idB);
        }
      }
      if (i === path.length) {
        break;
      }
      const state = path[i];
      if (prevID2ID.has(state.id)) {
        continue;
      }
      const id = ++lastID;
      switch (state.kind) {
        case StateKind.FIXED:
          if (circular.indexOf(state.data) < 0) {
            if (dataToID.has(state.data)) {
              prevID2ID.set(state.id, dataToID.get(state.data));
              continue;
            }
          }
          prevID2ID.set(state.id, id);
          dataToID.set(state.data, id);
          states[id] = {
            kind: StateKind.FIXED,
            id,
            data: state.data,
            nextStates: []
          };
          break;
        case StateKind.PARAMETERIC:
          if (paramNameToID.has(state.name)) {
            prevID2ID.set(state.id, paramNameToID.get(state.name));
            continue;
          }
          prevID2ID.set(state.id, id);
          paramNameToID.set(state.name, id);
          states[id] = {
            kind: StateKind.PARAMETERIC,
            id,
            name: state.name,
            nextStates: []
          };
          break;
        case StateKind.END:
          prevID2ID.set(state.id, id);
          states[id] = {
            kind: StateKind.END,
            data: state.data,
            id,
            nextStates: []
          };
          break;
      }
    }
    const firstId = prevID2ID.get(path[0].id);
    if (startState.nextStates.indexOf(firstId) < 0) {
      startState.nextStates.push(firstId);
    }
  }

  return states;
}

export function getAllPaths(states: types.StatesObj): Array<types.Path> {
  const ret: Array<types.Path> = [];

  const statesStack: types.Path = [states[0]];
  const pathStack: number[] = [-1];

  while (statesStack.length) {
    const selectedPath = pathStack.pop();
    const currentState = statesStack.pop();
    if (currentState.kind === StateKind.END) {
      ret.push([...statesStack.slice(1), currentState]);
    }
    const nextStateId = currentState.nextStates[selectedPath + 1];
    const nextState = states[nextStateId];
    if (!nextStateId) {
      continue;
    }
    statesStack.push(currentState);
    pathStack.push(selectedPath + 1);
    statesStack.push(nextState);
    pathStack.push(-1);
  }

  return ret;
}

function isFixed(path: types.Path): path is types.FixedStateArray {
  for (const state of path) {
    if (state.kind === StateKind.PARAMETERIC) {
      return false;
    }
  }
  return true;
}
