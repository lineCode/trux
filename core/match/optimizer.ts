// This file is to optimize a state machine generated by compiler.
import * as types from "./types.ts";
import { StateKind, refactorIds } from "./common.ts";

export function optimize(states: types.State[]): types.OptimizerData {
  const paths = getAllPaths(states);
  const fixed: string[] = [];
  const endsWith: string[] = [];
  const dynamicPaths: Array<types.State[]> = [];
  let minLength = Infinity;
  let maxLength = -Infinity;
  let endsWithDisabled = false;

  for (const path of paths) {
    if (isFixed(path)) {
      const data: string[] = [];
      for (const state of path) {
        data.push(state.data);
      }
      const str = data.join("");
      if (!fixed.includes(str)) {
        fixed.push(str);
        if (str.length < minLength) {
          minLength = str.length;
        }
        if (str.length > maxLength) {
          maxLength = str.length;
        }
      }
    } else {
      let len = 0;
      for (const state of path) {
        if (state.kind === StateKind.FIXED) {
          len += state.data.length;
        } else if (state.kind === StateKind.PARAMETERIC) {
          // A PARAMETERIC state must match at least 1 byte.
          len += 1;
        }
      }
      if (len < minLength) {
        minLength = len;
      }
      maxLength = Infinity;
      dynamicPaths.push(path);
      if (!endsWithDisabled) {
        const fixedEnd = getFixedEnd(path);
        if (fixedEnd === "") {
          endsWithDisabled = true;
          endsWith.splice(0);
          endsWith.push("");
        } else if (!endsWith.includes(fixedEnd)) {
          endsWith.push(fixedEnd);
        }
      }
    }
  }

  if (fixed.length === paths.length) {
    return {
      onlyFixed: true,
      minLength,
      maxLength,
      fixed,
      endsWith
    };
  }

  for (let i = 0; i < dynamicPaths.length; ++i) {
    dynamicPaths[i] = joinFixedStates(dynamicPaths[i]);
    dynamicPaths[i] = removeEmptyNodes(dynamicPaths[i]);
    checkPath(dynamicPaths[i]);
  }

  // Remmber: Test for H(:id)H
  // Also H(:id)/(H|P)?

  return {
    onlyFixed: false,
    minLength,
    maxLength,
    fixed,
    endsWith,
    states: remap(dynamicPaths, states)
  };
}

export function joinFixedStates(states: types.Path): types.Path {
  const ret: types.Path = [];

  for (let i = 0; i < states.length; ++i) {
    const state = states[i];
    if (state.kind === StateKind.FIXED) {
      const data: string[] = [state.data];
      let nextState = states[i + 1];
      while (nextState && nextState.kind === StateKind.FIXED) {
        data.push(nextState.data);
        nextState = states[++i + 1];
      }
      ret.push({
        ...state,
        data: data.join("")
      });
    } else {
      ret.push(state);
    }
  }

  return ret;
}

export function removeEmptyNodes(states: types.Path): types.Path {
  const ret: types.Path = [];

  for (const state of states) {
    if (state.kind === StateKind.FIXED) {
      if (state.data === "") {
        continue;
      }
    }
    ret.push(state);
  }

  return ret;
}

// This function is to check two things:
// 1. There shouldn't be two param with the same name in a path.
//  Example:
//    Invalid: "X/:id/:id"
//    Valid: "X/:id/:id2"
// 2. A path must not have two parameteric states next to each other.
//  Example:
//    Invalid: "Y/:r:p"
//    Valid: "Y/:r/:p"
export function checkPath(path: types.Path): void {
  const seen: string[] = [];
  let parametericAllowd = true;

  for (const state of path) {
    if (state.kind === StateKind.PARAMETERIC) {
      if (!parametericAllowd) {
        throw new Error("A parameter must not come after another parameter.");
      }
      if (seen.includes(state.name)) {
        throw new Error("A parameter name must be unique.");
      }
      parametericAllowd = false;
      seen.push(state.name);
    } else {
      parametericAllowd = true;
    }
  }
}

export function remap(
  paths: Array<types.State[]>,
  preStates: types.State[]
): types.State[] {
  //  return paths as any;
  const states: types.StatesObj = {};
  // TODO(qti3e);
  return [];
}

export function getFixedEnd(path: types.State[]): string {
  const data: string[] = [];
  for (let i = path.length - 1; i >= 0; --i) {
    const state = path[i];
    if (state.kind === StateKind.FIXED) {
      data.push(state.data);
    } else {
      break;
    }
  }
  return data.reverse().join("");
}

export function getAllPaths(states: types.State[]): Array<types.State[]> {
  const ret: Array<types.State[]> = [];

  const statesStack: types.State[] = [states[0]];
  const pathStack: number[] = [-1];

  while (statesStack.length) {
    const selectedPath = pathStack.pop();
    const currentState = statesStack.pop();
    if (currentState.kind === StateKind.END) {
      ret.push([...statesStack.slice(1), currentState]);
    }
    const nextStateId = currentState.nextStates[selectedPath + 1];
    const nextState = states[nextStateId];
    if (!nextStateId) {
      continue;
    }
    statesStack.push(currentState);
    pathStack.push(selectedPath + 1);
    statesStack.push(nextState);
    pathStack.push(-1);
  }

  return ret;
}

function isFixed(path: types.State[]): path is types.FixedStateArray {
  for (const state of path) {
    if (state.kind === StateKind.PARAMETERIC) {
      return false;
    }
  }
  return true;
}
